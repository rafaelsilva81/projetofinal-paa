<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Modelo de uso do MathJax (HTML+Latex)</title>

  <!-- MATHJAX 3 (através da CDN) -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- MATHJAX 3 (salvo no computador) -->
  <!-- <script type="text/javascript" async src="../../../Aplicativos/MathJax-master/es5/tex-mml-chtml.js" async></script> -->
</head>
<body>

<h1>Avaliação teórica (análise teórica de complexidade de pior caso).</h1>

<ol>
  <li>
    KMP : <br>
    <pre><code>
    funcao kmp_busca(padrao: string, texto: string):
    n = texto.tamanho()  				// \theta(1)
    m = padrao.tamanho()  				// \theta(1) 
    lps = [0]*m  						// \theta(1) 
    calcular_lsp(padrao, m, lps)  			// \theta(1)
    i = 0  						// \theta(1)
    j = 0  						// \theta(1)
    Enquanto i < n:  					// \theta(n)
        se texto[i] == padrao[j]:  				// \theta(n)
            i += 1  						// \theta(n)
            j += 1						// \theta(n)
        senao: 						// \theta(n)
            se j != 0:					// \theta(n)
                j = lps[j-1]					// \theta(n)
            senao:						// \theta(n)
                i += 1					// \theta(n)
        se j == m:					// \theta(n)
            print("padrao found at index :", i-j)		// \theta(n)
            j = lps[j-1]					// \theta(n)
    </code></pre>
Assim a complexidade do kmp_busca será de: \(6 \cdot \theta(1) + 12 \cdot \theta(n) = \theta(n)\),
    
    <pre><code>

    funcao calcular_lsp(padrao: string, m: int, lps: lista):
      len = 0  				  // \theta(1)
      i = 1					    // \theta(1)
      lps[0] = 0 				// \theta(1)

      Enquanto i < m:  			// \theta(m)
        se padrao[i] == padrao[len]:       // \theta(m)
            lps[i] = len+1			// \theta(m)
            len += 1			// \theta(m)
            i += 1				// \theta(m)
        senao:				// \theta(m)
            se len != 0:			// \theta(m)
                len = 0			// \theta(m)
            senao:				// \theta(m)
                lps[i] = 0			// \theta(m)
                i += 1			// \theta(m)
              </code></pre>

Assim a complexidade do calcular_lsp será de: \(3 \cdot \theta(1) + 11 \cdot \theta(m) = \theta(m)\).

Já que a função kmp_busca chama a funcao calcular_lsp, 
então na função calcular_lsp o padrão é pré processado considerando,
assim resultando na complexidade \(\theta(m)\)
que será somada com a complexidade resultando da função que a 
invocou que no caso é \theta(n), assim a complexidade do algoritmo será de \(\theta(n + m)\).

  </li>
</ol>

</body>
</html>
